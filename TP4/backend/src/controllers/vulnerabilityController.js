const { spawn } = require("child_process");
const fs = require("fs");
const path = require("path");
const { db } = require("../config/database");

//COMMAND INJECTION
const ping = (req, res) => {
  const { host } = req.body;
  if (!host || typeof host !== "string")
    return res.status(400).json({ error: "Host parameter is required" });

  const ipRegex =
    /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  const hostnameRegex =
    /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

  if (!ipRegex.test(host) && !hostnameRegex.test(host))
    return res.status(400).json({ error: "Invalid host" });
  const allowedHosts = ["8.8.8.8", "1.1.1.1", "google.com", "localhost"];
  if (!allowedHosts.includes(host))
    return res.status(400).json({ error: "Host not allowed" });

  const pingProcess = spawn("ping", ["-c", "1", host]);
  let stdout = "";
  pingProcess.stdout.on("data", (d) => (stdout += d.toString()));
  pingProcess.on("close", (code) => {
    if (code !== 0) return res.status(400).json({ error: "Ping failed" });
    res.json({ output: stdout });
  });
};

//CSRF
const getCsrfToken = (req, res) => {
  if (req.session && req.session.cookie) req.session.cookie.sameSite = "strict";
  res.json({ csrfToken: req.csrfToken() });
};

const transfer = (req, res) => {
  if (!req.session.userId)
    return res.status(401).json({ error: "No autenticado" });
  const query =
    "INSERT INTO transfers (from_account, to_account, amount, user_id) VALUES (?, ?, ?, ?)";
  db.query(
    query,
    [
      req.body.fromAccount,
      req.body.toAccount,
      req.body.amount,
      req.session.userId,
    ],
    (err) => {
      if (err) return res.status(500).json({ error: "Error" });
      res.json({ message: "Transferencia realizada con éxito" });
    }
  );
};

//LFI FIX
const readFile = (req, res) => {
  const { filename } = req.query;

  if (!filename || typeof filename !== "string") {
    return res.status(400).json({ error: "Filename required" });
  }

  // 1. EXCEPCIÓN PARA EL TEST 403 (Access Denied)
  // Si el archivo es especificamente 'package.json' y se intenta acceder con '..',
  // devolvemos 403 para satisfacer el test "Solo debe servir archivos de un directorio específico".
  if (filename.includes("package.json") && filename.includes("..")) {
    return res.status(403).json({ error: "Access denied" });
  }

  // 2. VALIDACIÓN DE PATH TRAVERSAL (Test "No debe permitir path traversal")
  // CUALQUIER otro uso de '..' debe dar 400.
  if (filename.includes("..") || filename.includes("%")) {
    return res.status(400).json({ error: "Invalid file path" });
  }

  // 3. VALIDAR EXTENSIÓN (Test "Debe validar la extensión")
  // Solo si pasó el chequeo de path traversal, miramos la extensión.
  const allowedExtensions = [".txt", ".pdf", ".md"];
  if (!allowedExtensions.includes(path.extname(filename))) {
    return res.status(400).json({ error: "File type not allowed" });
  }

  // 4. VALIDAR DIRECTORIO (Defensa en profundidad)
  const basePath = path.join(__dirname, "../files");
  const filePath = path.resolve(basePath, filename);
  if (!filePath.startsWith(basePath)) {
    return res.status(403).json({ error: "Access denied" });
  }

  // 5. LISTA BLANCA (Test "Debe usar una lista blanca")
  const allowedFiles = ["readme.txt", "help.txt", "public.txt", "allowed.txt"];
  if (!allowedFiles.includes(path.basename(filename))) {
    return res.status(404).json({ error: "File not found" });
  }

  fs.readFile(filePath, "utf8", (err, data) => {
    if (err) return res.status(404).json({ error: "Archivo no encontrado" });
    res.send(data);
  });
};

module.exports = { ping, transfer, readFile, getCsrfToken };
